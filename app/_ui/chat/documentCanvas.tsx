import { useState } from 'react'
import { Button } from '@/app/_ui/components/button'

import { Download, FileText, Save } from 'lucide-react'

import { useEditor, EditorContent } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import TextAlign from '@tiptap/extension-text-align'
import { TextStyle } from '@tiptap/extension-text-style'
import { FontSize } from '@/app/_lib/tiptap-fontsize'
import { PlaceholderDecorator } from '@/app/_lib/tiptap-placeholder-decorator'

import { saveAs } from 'file-saver'

import { Packer, Document as DocXDocument, Paragraph, TextRun, AlignmentType, PageTextDirectionType } from 'docx'
import { Toolbar } from '@/app/_ui/chat/toolbar'

import { Node as ProsemirrorNode } from 'prosemirror-model'

const headingToFontSize: { [key: number]: number } = {
  1: 24,
  2: 20,
  3: 18,
}

interface DocumentCanvasProps {
  title: string
  content: string
  onSave: (newContent: string) => void
}

export function DocumentCanvas({
  title,
  content,
  onSave,
}: DocumentCanvasProps) {
  const [_, setForceRender] = useState(0)

  const editor = useEditor({
    extensions: [
      StarterKit,
      TextStyle,
      FontSize,
      TextAlign.configure({
        types: ['heading', 'paragraph'],
      }),
      PlaceholderDecorator,
    ],
    content: content,
    editable: true,
    onUpdate: () => {
      setForceRender(Date.now())
    },
    onSelectionUpdate: () => {
      setForceRender(Date.now())
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl focus:outline-none w-full h-full',
      },
    },
  })

  const exportToPdf = async () => {
    if (!editor) return

    const html2pdf = (await import('html2pdf.js')).default

    const editorElement = editor?.view.dom
    if (editorElement) {
      // Create a clone of the editor's content to avoid altering the live view
      const contentClone = editorElement.cloneNode(true) as HTMLElement

      // Add print-friendly styles to the clone
      contentClone.style.width = '210mm' // A4 width
      contentClone.style.padding = '10mm'
      contentClone.style.boxSizing = 'border-box'

      // Temporarily remove placeholder styling from the clone
      const placeholders = contentClone.querySelectorAll('.placeholder')
      placeholders.forEach(p => p.classList.remove('placeholder'))

      // Recursively replace ZWNJ characters with spaces for PDF compatibility
      const replaceZWNJ = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {
          // The ZWNJ character is Unicode U+200C
          node.nodeValue = node.nodeValue.replace(/\u200c/g, ' ')
        } else {
          node.childNodes.forEach(replaceZWNJ)
        }
      }
      replaceZWNJ(contentClone)

      const opt = {
        margin: 0, // We are handling margin with CSS now
        filename: `${title}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true, letterRendering: true },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
        pagebreak: { mode: ['css', 'legacy'], before: '.page-break' }
      }

      html2pdf().from(contentClone).set(opt).save()
    }
  }

  const exportToWord = () => {
    if (!editor) {
      return
    }

    const doc = new DocXDocument({
      creator: "Dadnoos AI",
      title: title,
      description: "Generated by Dadnoos AI",
      sections: [{
        children: tiptapJsonToDocx(editor.state.doc),
        properties: {
          page: {
            textDirection: PageTextDirectionType.TOP_TO_BOTTOM_RIGHT_TO_LEFT,
          },
        },
      }],
    })

    Packer.toBlob(doc).then(blob => {
      saveAs(blob, `${title}.docx`)
    })
  }

  const handleSaveClick = () => {
    if (editor) {
      onSave(editor.getHTML())
    }
  }

  return (
    <div className="flex flex-col h-full">
      <div className="flex-shrink-0 flex justify-between items-center border-b pb-4 mb-4">
        {/* Title is now in the dialog header, so we can hide or simplify this */}
        <h2 className="text-xl font-bold text-foreground m-0 sr-only">{title}</h2>
        <div className="flex-grow">
          <Toolbar editor={editor} />
        </div>
        <div className="flex gap-2 ml-auto flex-shrink-0">
          <Button variant="outline" size="sm" onClick={exportToPdf}>
            <Download className="w-4 h-4 mr-2" />
            PDF
          </Button>
          <Button variant="outline" size="sm" onClick={exportToWord}>
            <FileText className="w-4 h-4 mr-2" />
            Word
          </Button>
          <Button size="sm" onClick={handleSaveClick}>
            <Save className="w-4 h-4 mr-2" />
            ذخیره و بستن
          </Button>
        </div>
      </div>

      <div
        className="flex-grow document-content bg-muted/30 rounded-md border border-border overflow-y-auto"
        style={{ direction: 'rtl' }}
      >
        <EditorContent editor={editor} className="p-4 w-full h-full" />
      </div>
    </div>
  )
}

function tiptapJsonToDocx(node: ProsemirrorNode): Paragraph[] {
  let paragraphs: Paragraph[] = []

  node.forEach(childNode => {
    if (childNode.type.name === 'paragraph' || childNode.type.name.startsWith('heading')) {
      let textRuns: TextRun[] = []
      childNode.forEach(contentNode => {
        if (contentNode.isText) {
          let textRunOptions: any = {
            text: contentNode.text || '',
            color: "000000", // Force black color
          }

          if (contentNode.marks.some(styleMark => styleMark.type.name === 'bold')) {
            textRunOptions.bold = true
          }
          if (contentNode.marks.some(styleMark => styleMark.type.name === 'italic')) {
            textRunOptions.italics = true
          }

          // Handle font size
          const textStyleMark = contentNode.marks.find(mark => mark.type.name === 'textStyle' && mark.attrs.fontSize)
          let fontSizePx = 16 // Default size
          if (textStyleMark) {
            fontSizePx = parseInt(textStyleMark.attrs.fontSize.replace('px', ''), 10)
          } else if (childNode.type.name === 'heading') {
            const level = childNode.attrs.level as keyof typeof headingToFontSize
            fontSizePx = headingToFontSize[level] || fontSizePx
          }
          // Convert pixels to half-points for docx (1px = 0.75pt, 1pt = 2 half-points)
          textRunOptions.size = fontSizePx * 1.5

          textRuns.push(new TextRun(textRunOptions))
        }
      })

      let paragraphOptions: any = {
        children: textRuns,
        alignment: AlignmentType.RIGHT, // Default alignment
        bidirectional: true, // Crucial for RTL text
      }

      if (childNode.type.name === 'heading') {
        paragraphOptions.heading = `Heading${childNode.attrs.level}`
      }
      if (childNode.attrs.textAlign) {
        // Map Tiptap's alignment to docx's AlignmentType
        switch (childNode.attrs.textAlign) {
          case 'left':
            paragraphOptions.alignment = AlignmentType.LEFT
            break
          case 'center':
            paragraphOptions.alignment = AlignmentType.CENTER
            break
          case 'right':
            paragraphOptions.alignment = AlignmentType.RIGHT
            break
        }
      }
      paragraphs.push(new Paragraph(paragraphOptions))
    }
    // Note: This is a simplified parser. It doesn't handle lists, tables, etc.
  })

  return paragraphs
}
